{
  "language": "Solidity",
  "sources": {
    "contracts/QuizNFT.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.0;\n\n// import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// contract QuizNFT is ERC721Enumerable, Ownable {\n//     using Strings for uint256;\n\n//     struct Quiz {\n//         string url;\n//         address owner;\n//     }\n\n//     uint quizCount;\n//     mapping(uint256 => Quiz) public quizzes;\n//     mapping(address => uint256[]) public quizzesCreatedByWallet;\n\n//     uint256 private _tokenIdCounter;\n\n//     constructor() ERC721(\"Quiz NFT\", \"QNFT\") {\n//         _tokenIdCounter = 1;\n//     }\n\n//     function generateQuiz(string memory _url) external {\n//         require(bytes(_url).length > 0, \"URL cannot be empty\");\n\n//         quizzes[quizCount] = Quiz({\n//             url: _url,\n//             owner: msg.sender\n//         });\n\n//         quizzesCreatedByWallet[msg.sender].push(quizCount);\n//         quizCount++;\n//     }\n\n//     function mintNTFQuiz() external {\n//         uint256 tokenId = _tokenIdCounter;\n//         _mint(msg.sender, tokenId);\n//         _tokenIdCounter++;\n//         // string dynamicNFT = buildURI(tokenId);\n//     }\n\n//     function buildURI(uint256 id) internal view returns (string memory) {\n//         address tokenMinter = s_tokenIdToTokenMinter[id];\n//         uint256 mintedBlockNumber = s_tokenIdToBlockNumber[id];\n//         uint256 donatedAmount = s_tokenIdToDonation[id];\n\n//         Theme currentTheme = s_tokenIdToTheme[id];\n//         string memory backgroundColor = (currentTheme == Theme.DARK) ? \"#2A3655\" : \"#F5F5F5\";\n//         string memory textColor = (currentTheme == Theme.DARK) ? \"#F5F5F5\" : \"#2A3655\";\n\n//         bytes memory image = abi.encodePacked(\n//             \"data:image/svg+xml;base64,\",\n//             Base64.encode(\n//                 bytes(\n//                     abi.encodePacked(\n//                         '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n//                         '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" viewBox=\"0 0 400 400\" preserveAspectRatio=\"xMidYMid meet\">',\n//                         '<style type=\"text/css\"><![CDATA[text {font-family: monospace; font-size: 21px; fill: ',\n//                         textColor,\n//                         \";} .h1 {font-size: 40px; font-weight: 600; fill: \",\n//                         textColor,\n//                         \";}]]></style>\",\n//                         '<rect width=\"400\" height=\"400\" fill=\"',\n//                         backgroundColor,\n//                         '\" />',\n//                         '<text x=\"20\" y=\"30\">On block #',\n//                         LibString.toString(mintedBlockNumber),\n//                         \"</text>\",\n//                         '<text x=\"20\" y=\"90\" style=\"font-size:14px;\">0x',\n//                         addressToString(tokenMinter),\n//                         \"</text>\",\n//                         '<text x=\"20\" y=\"130\">found wisdom in</text>',\n//                         '<text class=\"h1\" x=\"20\" y=\"175\">0 to BuidlGuidl</text>',\n//                         unicode'<text x=\"20\" y=\"210\">and donated Îž ',\n//                         weiToEtherString(donatedAmount),\n\n//                         unicode'<text x=\"20\" y=\"380\">and good luck on your way!</text>',\n//                         \"</svg>\"\n//                     )\n//                 )\n//             )\n//         );\n\n//         return string(\n//             abi.encodePacked(\n//                 \"data:application/json;base64,\",\n//                 Base64.encode(\n//                     bytes(\n//                         abi.encodePacked(\n//                             '{\"name\":\"',\n//                             name(),\n//                             '\", \"image\":\"',\n//                             image,\n//                             unicode'\", \"description\": \"Consider this NFT as an eternal thank you note for your donation. Hope to see you building with us in the future! <3\"}'\n//                         )\n//                     )\n//                 )\n//             )\n//         );\n//     }\n\n//     function getAllQuizzes() external view returns (Quiz[] memory) {\n//         Quiz[] memory result = new Quiz[](quizCount);\n//         for (uint256 i = 0; i < quizCount; i++) {\n//             result[i] = quizzes[i];\n//         }\n//         return result;\n//     }\n\n//     function getAllNFTs() external view returns (uint256[] memory) {\n//         uint256 totalSupply = totalSupply();\n//         uint256[] memory result = new uint256[](totalSupply);\n//         for (uint256 i = 0; i < totalSupply; i++) {\n//             result[i] = tokenByIndex(i);\n//         }\n//         return result;\n//     }\n\n//     function getAllQuizzesCreatedByMe() external view returns (uint256[] memory) {\n//         return quizzesCreatedByWallet[msg.sender];\n//     }\n// }\n"
    },
    "contracts/contracts-worldcoin/ByteHasher.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.10;\n\n// library ByteHasher {\n//     /// @dev Creates a keccak256 hash of a bytestring.\n//     /// @param value The bytestring to hash\n//     /// @return The hash of the specified value\n//     /// @dev `>> 8` makes sure that the result is included in our field\n//     function hashToField(bytes memory value) internal pure returns (uint256) {\n//         return uint256(keccak256(abi.encodePacked(value))) >> 8;\n//     }\n// }\n"
    },
    "contracts/contracts-worldcoin/IWorldID.sol": {
      "content": "// //SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.10;\n\n// interface IWorldID {\n//     /// @notice Reverts if the zero-knowledge proof is invalid.\n//     /// @param root The of the Merkle tree\n//     /// @param groupId The id of the Semaphore group\n//     /// @param signalHash A keccak256 hash of the Semaphore signal\n//     /// @param nullifierHash The nullifier hash\n//     /// @param externalNullifierHash A keccak256 hash of the external nullifier\n//     /// @param proof The zero-knowledge proof\n//     /// @dev  Note that a double-signaling check is not included here, and should be carried by the caller.\n//     function verifyProof(\n//         uint256 root,\n//         uint256 groupId,\n//         uint256 signalHash,\n//         uint256 nullifierHash,\n//         uint256 externalNullifierHash,\n//         uint256[8] calldata proof\n//     ) external view;\n// }\n"
    },
    "contracts/contracts-worldcoin/Quizzes.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.13;\n\n// import { ByteHasher } from \"./helpers/ByteHasher.sol\";\n// import { IWorldID } from \"./interfaces/IWorldID.sol\";\n\n// contract Quizzes {\n//     using ByteHasher for bytes;\n\n//     /// @notice Thrown when attempting to reuse a nullifier\n//     error InvalidNullifier();\n\n//     /// @dev The World ID instance that will be used for verifying proofs\n//     IWorldID internal immutable worldId;\n\n//     /// @dev The contract's external nullifier hash\n//     uint256 internal immutable externalNullifier;\n\n//     /// @dev The World ID group ID (always 1)\n//     uint256 internal immutable groupId = 1;\n\n//     /// @dev Whether a nullifier hash has been used already. Used to guarantee an action is only performed once by a single person\n//     mapping(uint256 => bool) internal nullifierHashes;\n\n\n//     /// @param _worldId The WorldID instance that will verify the proofs\n//     /// @param _appId The World ID app ID\n//     /// @param _actionId The World ID action ID\n\n//     // Variables\n//     mapping(address => uint) public balances;\n//     mapping(address => Profile[]) public profiles;\n//     mapping(address => Fund[]) public fundings;\n\n//     struct Profile {\n//         uint256 id;\n//         string memberName;\n//         address userWallet;\n//         uint256 dateToWithdraw;\n//         uint256 donationBalance;\n//     }\n\n//      struct Fund {\n//         uint256 id;\n//         string message;\n//         uint256 amount;\n//         address userWallet;\n//         uint256 withdrawDate;\n//     }\n\n//     constructor(\n//         IWorldID _worldId,\n//         string memory _appId,\n//         string memory _actionId\n//     ) {\n//         worldId = _worldId;\n//         externalNullifier = abi\n//             .encodePacked(abi.encodePacked(_appId).hashToField(), _actionId)\n//             .hashToField();\n//     }\n\n//         function AddFamilyMember(\n//        string memory _memberName,\n//        address _userWallet,\n//        uint256 _dateToWithdraw\n//     ) external\n//     {\n//         uint id = profiles[msg.sender].length;\n//         profiles[msg.sender].push(Profile(\n//             id,\n//             _memberName,\n//             _userWallet,\n//             _dateToWithdraw,\n//             0\n//         ));\n//     }\n\n//     function CreateFund(\n//         address _userWallet,\n//         string calldata _messsage,\n//         uint256 _withdrawDate\n//     ) payable external {\n//         uint id = fundings[msg.sender].length;\n//         fundings[msg.sender].push(\n//             Fund(\n//                 id,\n//                 _messsage,\n//                 msg.value,\n//                 _userWallet,\n//                 _withdrawDate\n//             )\n//         );\n//         balances[_userWallet] += msg.value;\n//     }\n\n//     // parent Wallet\n//     function retriveMembers(address userWallet) external view returns (Profile[] memory) {\n//         return profiles[userWallet];\n//     }\n\n//     // child wallet\n//     function retrieveAllFundings(address userWallet) external view returns (Fund[] memory) {\n//         return fundings[userWallet];\n//     }\n\n//     function claimFundingById() external {\n//         (bool sent,) = msg.sender.call{value: balances[msg.sender]}(\"\");\n//         require(sent, \"Failed Claim\");\n//         balances[msg.sender] = 0;\n//     }\n\n\n\n//     /// @param signal An arbitrary input from the user, usually the user's wallet address (check README for further details)\n//     /// @param root The root of the Merkle tree (returned by the JS widget).\n//     /// @param nullifierHash The nullifier hash for this proof, preventing double signaling (returned by the JS widget).\n//     /// @param proof The zero-knowledge proof that demonstrates the claimer is registered with World ID (returned by the JS widget).\n//     /// @dev Feel free to rename this method however you want! We've used `claim`, `verify` or `execute` in the past.\n//     function verifyAndExecute(\n//         address signal,\n//         uint256 root,\n//         uint256 nullifierHash,\n//         uint256[8] calldata proof\n//     ) public {\n//         // First, we make sure this person hasn't done this before\n//         if (nullifierHashes[nullifierHash]) revert InvalidNullifier();\n\n//         // We now verify the provided proof is valid and the user is verified by World ID\n//         worldId.verifyProof(\n//             root,\n//             groupId,\n//             abi.encodePacked(signal).hashToField(),\n//             nullifierHash,\n//             externalNullifier,\n//             proof\n//         );\n\n//         // We now record the user has done this, so they can't do it again (proof of uniqueness)\n//         nullifierHashes[nullifierHash] = true;\n\n//         // Finally, execute your logic here, for example issue a token, NFT, etc...\n//         // Make sure to emit some kind of event afterwards!\n//     }\n// }\n"
    },
    "contracts/devToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract DevToken is IERC20, Ownable {\n    string public name = \"SocialToken\";\n    string public symbol = \"SOC\";\n    uint8 public decimals = 18;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    constructor(uint256 initialSupply) {\n        _mint(msg.sender, initialSupply * 10**uint256(decimals));\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, msg.sender, currentAllowance - amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] -= amount;\n        _totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function mint(uint256 amount) public onlyOwner {\n        _mint(msg.sender, amount * 10**uint256(decimals));\n    }\n\n    function burn(uint256 amount) public onlyOwner {\n        _burn(msg.sender, amount * 10**uint256(decimals));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}